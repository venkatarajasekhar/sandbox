Q: Where is the admin console?
http://localhost:8080/_ah/admin/datastore
You can  
* Datastore Viewer          - view or create entries in the datastore
* Datastore Indexes
* Datastore Stats
* Interactive Console       - run python code interactively
* Memcache Viewer
* Task Queues
* Cron Jobs
* XMPP
* Inbound Mail
* Backends
* Text Search

Q: Where is the datastore file when in devel mode?
/tmp/dev_appserver.datastore
Note that this can be changed from the command line


Q: is the admin console available on GAE? 
Yes! This is the dashboard!
https://appengine.google.com/dashboard

Q: When running the development server, which are the key URI?
http://localhost:8080/_ah/admin         # Localhost dashboard
http://localhost:8080/_ah/login         # Login page (no password because localhost)


Q: What is a YAML file?
Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.
In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures. Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments.
YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required.
More @ http://yaml.org/spec/1.2/spec.html

Q: How to configure the gae application?
Edit the app.yaml file
More @ https://developers.google.com/appengine/docs/python/config/appconfig#Configuring_Libraries

Q: What is the purpose of escaping?
Python process input string without knowing that it is HTML.
If not escaped, the user can manipulate the HTML
ex: > shouldn't be part of the input (well unless it is escaped)
"   --> &quot;
&   --> &amp;
etc

Q: What is the problem with a POST returning content?
If page is reloaded, the browser resumit the form (POST is resent).
If you save the URL of the success page, this URL points to the form.
As a matter of fact, the form html page will be returned instead of the success page
==> Always use a redirect (bounce the user) in a *successfull* POST request
    For non-successfull request, reprint the form with its content

Q: Give me a brief intro to the datastore.
Tables are call entities in GAE
Columns are not fixed, i.e entries of the same entities do not have to use the same columns
i==> You can change the columns as you are developing
Every entities have an ID
Entities have a notion of parents and ancestors
ex:
Reddit --> link
Give me all the link of reddit
==> get familiar with the docs

Q: What is GQL?
GQL is a simplified version of SQL

Q: How does GQL compare to SQL?
All queries starts with SELECT *
- no joins possible

Run arbitrary queries
All queries must be indexed
==? indexes are build for us

Q: Is GAE datastore sharded and replicated?
Yes
* No need to think about scaling (too much)
* queries will be quick (because they have to be simle)
* will have to think about consistency

Q: What are datastore types?
Interger, Float, String, Date, Time, DateTime, Email, Link, PostlaAddress, Text, Boolean, etc.

Note that String < 500 chars, is indexed, and cannot contain carriage return.
while Text > 500 chars and NOT indexes <-- cannot be queried

class Art(db.Model):                                    <-- name of the table
    title = db.StringProperty(required=True)            <-- Mandatory field enforced in db (otherwise exception)
    art = db.TextProperty(required=True)
    created_at = db.DateTime(auto_now_add = True)

Q: How to query the database?
cursor_arts = db.GqlQuery("SELECT * FROM Art order created_at desc")
!!! All GQL queries start with select *
!!! Art is the name of the class/table
In template:
{% for post in posts %} 
    <h1>{{post.subject}}</h1>
    <p>{{post.content}}</p>
{% endfor %}

#----------------------------------------------------------------------
Q: What is a permalink?
In a blog, you have several posts.
A permalink is URL that link a particular post.
http://www.example.com/blog/posts/123       
Is a URL to the post with ID 123.
Note that ID can be strings 
#----------------------------------------------------------------------

Q: Which standard libraries are supported in GAE?
Most of the standard python libraries are supported
http://docs.python.org/modindex.html
but a few
https://developers.google.com/appengine/kb/libraries

    ctypes          - C to python - A foreign function library for Python.
    sqlite          - Unsupported database = A DB-API 2.0 implementation using SQLite 3.x.
    ssl/_ssl        - ??? - TLS/SSL wrapper for socket objects
    fcntl           - Unix specific = The fcntl() and ioctl() system calls
    spwd            - Unix specific = The shadow password database (getspnam() and friends)
    pwd             - Unix specific 
    grp             - unix specific = The group database (getgrnam() and friends)
    syslog          - Unix specific = An interface to the Unix syslog library routines.
    select          - ??? - Wait for I/O completion on multiple streams.
    _socket         - ??? - Low-level networking interface.

Note that to use the supported standard python libraries, you do not need to put them in the yaml file

  
Q: Which 3rd party libraries are supported in GAE? 
The App Engine Python 2.7 runtime includes several third-party libraries that your application can use.
Go in the google_appengine directory are look in the .../lib directory
Those supported libraries are 3rd party.
Other 3rd party libraries needs to be installed on the system (ex: PIL)
To include those libs in your code, you MUST modify the app.yaml file.
django      - A full-featured web application framework for Python.
jinja2      - A modern and designer friendly templating language for Python.
lxml        - A Pythonic binding for the C libraries libxml2 and libxslt.
markupsafe  - A XML/HTML/XHTML markup safe string for Python.
numpy       - A general-purpose library for array-processing.
PIL         - A library for creating and transforming images.
PyAMF       - A library that provides (AMF) Action Message Format functionality.
pycrypto    - A library of cryptography functions such as random number generation.
setuptools  - A library that provides package and module discovery capabilities.
webapp2     - A lightweight Python web framework.
webob       - A library that provides wrappers around the WSGI request environment.
yaml        - A library for YAML serialization and deserialization.
More@ https://developers.google.com/appengine/docs/python/tools/libraries27

Q: When do we cache?
caching = storing results of operations so that future requests return faster
- computation is slow
- computation will run multiple times
- when the output is the same for a partuclar input
- your provider charges for db access

Q: What is a cache hit?
If the result of a requested operation is in the cache. then it is a catch-hit

Q: What is a cache miss?
If the result of a requested  operation is not in the cache, then it is it is called a cache-miss!

Q: How to build a Query?
!!! A query is an object and is not executed until you FETCH it !
q = Player.all()                                # q is a query to get all the Player's entries from the database
q = db.GqlQuery("SELECT * FROM Player")         # Same as above
q = db.Query(Player)                            # Same as above! 
q = db.Query(Player).filter('name =', 'toto')    # q is a query to find a subset of the Player entries
q = db.Query(Player).order('-age')              # q is a query to find all the Player's entries. Order in descending order from age
q = db.Query(Player).filter('age >', 20)        # q is a query to find a subset of the Player's entries
q = db.GqlQuery("SELECT * FROM Player WHERE age > 20 AND age < 30 LIMIT 10 OFFSET 5 ORDER BY age DESC")
q = db.GqlQuery("SELECT * FROM Player WHERE age > :1 AND age < :2 LIMIT 10 OFFSET 5 ORDER BY age DESC", 20, 30)
q = db.GqlQuery("SELECT * FROM Player WHERE age > :min AND age < :max LIMIT 10 OFFSET 5 ORDER BY age DESC", min=20, max=30)
q = Player.gql("WHERE age > :1", 20)

!!! Beware: q.filter('name =', 'toto') is correct, while q.filter('name=', 'toto') may not be. There is a space

Q: How to build key queries?
Key queries are queries that returns only keys (not objects)
q = db.Query(Player, key_only=True)
q = db.GqlQuery('SELECT __key__ FROM Player')
for key in q.run():                             # Queries is turned into a QueryIterator (an Iterable)
!!! In the for loop, the '.run()' is assumed and not required

Q: How do you execute an existing query?
q.fetch(1000)                                   # q is executed, every entries are loaded in memory (very expensive operation!)
q.get()                                         # q is executed. Only one entry is loaded in memory.
q.fetch(10, offset=20)                          # q is executed with the limit=10 and 
q.count()                                       # q count, but be default the maximum count is 1000!
q.count(100)                                    # q count, but only up to 100
for player in q.run():                          # q is iterable in python. An iterable load the query one by one in the memory. (Better than fetch for memory management)

Q: What are collections?
class Book(db.Model):
    title = db.StringProperty()
    author = db.StringProperty()
class BookReview(db.MOdel):
    book = db.ReferenceProperty(Book, collection_name='reviews')

b = Book()
br= BookReview()
br.book = b
br.book = b.key()                               # Same as above

for review in b.reviews:
    # review is a BookReview instance

A collection is a back-reference property, the API performs a datastore query for all BookReview entities 
whose reference property equals the key of the Book.
A COLLECTION IS A QUERY !
The FOR LOOP EXECUTE THE QUERY!

Q: What can you do with collections?
You can append filter, orer, limit, etc.... like a normal query!

Q: What are reference (i.e ReferenceProperty)?
Used in One-to-many relationships
class FirstModel(db.Model):
    prop = db.IntegerProperty()
class SecondModel(db.Model):
    reference = db.ReferenceProperty(FirstModel)
obj1 = FirstModel()
obj1.put()
# A reference value is the key of another entity.
obj2.reference = obj1.key()
# Assigning a model instance to a property uses the entity's key as the value.
obj2.reference = obj1
obj2.put()

Q: How to use references?
try:
  obj1 = obj2.reference
except db.ReferencePropertyResolveError:
  # Referenced entity was deleted or never existed.

Q: What is the difference between query.fetch(limit=100) and query.run(batch_size=100)?
They are the same if number of entries returned are <=100.
If the machine entries is > 100, the run command will return them.
The bacth-size specify the number of item to fetch and load in memory at one.
Also Run returns a QueryIterator (a python iterator). 
That is only 'batch_size' database entries are loaded in memory at a time.
With fetch, the entire set (up to the limit) is loaded in memory. 
The memory needs to be big enough, ie managed.

Q: How to user keys?
user = User()
d.filter("user =", user.key() )                 #
d.filter("user", user.key()                     #
d.filter("user", user )                         # Not sure this one works!
d.filter("user =", db.Key("%s" % user.key()) )  #

Q: What is the IN operator?
The IN operator compares value of a property to each item in a list. 
The IN operator is equivalent to many = queries, one for each value, that are ORed together.
An entity whose value for the given property equals any of the values in the list can be returned for the query.
SELECT * FROM Person WHERE name IN ('Betty', 'Charlie')     # ok, Documented!
q.filter('name IN', ('Betty', 'Charlie'))                   # Equivalent?
q.filter('name IN', ['Betty', 'Charlie'])                   # Equivalent?

!!! Note that the datastore can't actually do this kind of OR query; 
!!! This syntax results in 2 queries being done and the results merged. 
!!! Using long lists of values for the IN condition is a Bad Idea.

!!! The problem with this is that it quickly becomes slow and maxes out at 30 values. 

Q: What are ancestor used for?
You can query on the descendeants (db.query_descendants(parent_entity) )

Q: How to do a OR query in GAE?
http://tornblue.com/post/11310830291/app-engine-how-to-do-an-efficient-or-query ?
IN ?
http://stackoverflow.com/questions/3714972/google-app-engine-or-query-python ?

There is probably a problem in the model you are using.
Ancestry (parent/child) may be a solution
Ex: friendship --> User / friend

Q: Hierachy?
Parent is the one that makes the action
Child = the action
ex: like, dislike, befriend ~ REST action

Q: How to get the length of a list?
In jinja tempate {% if listProp | length > 1 %} 
