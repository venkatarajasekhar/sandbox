#-----------------------------------------------------------------------
# VIRTUAL, PURE VIRTUAL, STUB, DOWNCASTING, OVERRIDE

Q: What is a virtual function?
A virtual function or virtual method is a function or method whose behavior can be 
overridden within an inheriting class by a function with the same signature. 
This concept is a very important part of the polymorphism
!!! A virtual function has a default implementation in the base class
!!! A pure virtual function is a virtual function without an implementation in the base class
!!! Pure virtual functions are used for interface definition
More @ http://en.wikipedia.org/wiki/Virtual_function

Q: What is the scope of the virtual keyword?
Once a function is declared virtual, it remains virtual all the way down the inheritance hierarchy 
from that point, even if that function is not explicitly declared virtual when a derived class overrides it.
==> specify virtual at every level for program clarity!

Q: What is a pure specifier?
The "=0" is a pure specifier!
It means the function has no implementation, but the code can still call it and compile!

Q: What is the difference between a stub function and a pure virtual function?
A stub function is a function with minimum implementation (i.e return an error code)
Stub functions can be inherited and do not need to be reimplemented before the sub class can be instantiated.
(Often this is because it is not used in our case)
A pure virtual function MUST be implemented in the derived class regardless whether it is used or not.

Q: What is the difference between a virtual and pure virtual function?
Pure virtual: the base class doesn't provide an implementation, the CONCRETE derived class MUST override all the virtual function of the abstract class
ex: class 2dShape: virtual void draw() const =0
virtual: the base class provide an implementation
ex: class 2dshape: virtual void getName() const
Here virtual because base class implementation is default

Q: What are pure virtual function?
A class is made abstract by declaring one or more of its virtual functions to be "pure"
A pure virtual function is specified by placing "=0" in its declaration, as in
virtual void draw() const =0;       // pure virtual function
Typically pure virtual functions are declared in 'interfaces'
!!! An object can ONLY be instantiated from a class with no pure virtual functions
!!! Pure virtual functions MUST to be overwritten in a sub class before it can be instantiated
!!! Pure virtual functions can be called ever so there is no implementation
!!! Pure virtual functions compile even so there is no code.

Q: What is downcasting?
Read answer to above question.
But beware, downcasting is dangerous!
The preferred method is to use virtual functions

Q: Why would a function be declared as virtual in a base-class?
To avoid downcasting ! In other words, a base-class pointer that points to a derived-class object
CAN call derived-class functions.
==> The program determine at runtime which class member function to call  ( = LATE BINDING, DYNAMIC BINDING!)
==> The called functions are not from the class of the pointer, but from the class of the object

Q: what is a virtual base?
Diamond double inheritance without confusion

Q: overrride and final keywords?
A method that is declared final in the super class cannot be overridden; 
also, a method can be declared override to make the compiler check that it overrides a method in the base class.


#-----------------------------------------------------------------------
# INHERITANCE

Q: Simple inheritance code?
class Mercedes : public Car                      # <-- Mercedes is derived from the Car class
{
    public:
    protected:
    private:
}
Q: What are base class, derived class, inheritance?
base class = super class
derived class = subclass
inheritance is a way to use code reuse
the code only appears in the base class and is automatically inserted in its derived classes as we go.
==> easier to maintain, debug, modify, etc... because the source code exists only in 2 files (h and cpp of base class)

Q: what is a virtual base?
Diamond double inheritance without confusion

Q: What is multiple inheritance?

#-----------------------------------------------------------------------
# AUTOMATIC vs STATIC

Q: What are automatic and static?
2 of 4 storage specifiers

Q: What is an automatic object?
Objects with automatic storage duration, or automatic objects for short, 
are created automatically upon entering a function or a block. 
They are destroyed and their storage is reclaimed automatically 
when the function or block in which they are declared exits. 
Thus, on each entry into a function or a block, a fresh set of its automatic objects is created. 
The default value of automatic variables and non-class objects is indeterminate. 
Automatic objects have no linkage; 
you cannot refer to them from a different translation unit and their visibility 
is limited to the scope in which they are declared.
==> a variable with a scope!

Q: What is a static object?
A non-automatic object!
Initialized only once, when the definition is first read
Destructed once, at the end of the main

Q: Difference between C++ and C static?
In C, static means his function can only be seen in this file
In C++, static means a function can be called without an instantiated object, 
as normally member functions (methods) must be called using an instantiation of the class, 
though with this keyword, you don't need it.

Q: What are the difference between a static variable, a static object, 
a static data member, a static member function?
static is opposed to automatic (or default behavior)
A static variable 
    - Come from C. 
    - Are defined and initialize only once. The memory allocation is free'd at the end of the main
A static object 
    - is similar to a static variable, except they use constructor and destructor
A static data member 
    - is a variable shared by every instance (ex: number of instance created). 
    - member of a class
    - Accessible (if public) even if no instance is created.  MyClass::MyVariable
A static member function 
    - is accessible through the class MyClass::MyFunction() 
    - is independent from the instance
    - doesn't have a 'this' pointer passed as by the compiler

Q: What is a static data member or static function member?
static data member is a data member that is share by all the instance 
ex: numberOfInstance
A static function member is usually an accessor to that static data member
The keywords static only appears in the interface (include h), not in the class declaration (cpp)

Q: What is particularity of a static data member or static function member?
They can be accessed without an instance
eg: MyClass::GetNumberOfInstances()
!!! static functions DO NOT HAVE 'this' pointer !

Q: What is the difference between static and global variables/objects, etc?
Global objects are instantiated before the main
Both are destroyed at the end of the main

#-----------------------------------------------------------------------
# PUBLIC, PRIVATE, PROTECTED

Q: In a class interface, what is public vs private vs protected?
An object expose all its public data members and function member to the world!
The private data/function members are only accessible by the object itself
(in the code of its member functions)
protected data/function members are are only accessible to the class instances and derived class instances

Q: In a class interface, what does protected means?
Protected is an intermediary access right between public and private.
It comes into play with inheritance.
Indeed, a derived class cannot access private members of its base class!    <-- WHAOO !!!
To allow a derived class to access non-public members, that member needs to be declared as protected!
An alternative is to use getters and setters (mutator and accessor) for every private data. (but beware of overhead due to function calls)
!!! Function are either private or public, but not protected. Is that true?

Q: When is protected data member an issue? What is the purpose of mutators and accessor (getter and setter)?
VALIDATION !
+ access of private data?
!!! If you change the name of the var (and did not use mutators/accessors), you need to go through the code of all the derived classes.

Q: When to use private over protected?
when validation is required!
When the name of the data member can change (but the mutator and accessor won't!)
==> If base class is also heavily developed and changes to the base class are frequent!

Q: In a class interface, can a function be protected?
Private functions are utility/helper function.
If you want that function to be accessible from the derived class, then ...
??? IS THAT TRUE ???
==> no getter or setter possible for private function!

Q: Are private function, etc, inherited?
No

Q: How can private variables be accessible from a derived class?
By using a public accessor (or a public member function who reads/accesses those private variables)
ex:
void Mercedes::print() const { // print() method of derived class
   Car::print();  // Invoke parent print() method.
   std::cout << "; Height= " << this->height;
}

#-----------------------------------------------------------------------
# POLYMORPHISM

Q: How is polymorphism implemented?
Three levels of Pointers to implement polymorphism.
1/ pointer on the object (could also be reference)
2/ object has a pointer on a vtable
3/ vtable has a pointer on the function

Q: What is polymorphic behavior?
basePtr->print()
The same message -- print, in this case -- sent (off a base class pointer/or reference) to a variety of 
objects related by inheritance to that case class, takes on many forms.
This is polymorphic behavior.

#-----------------------------------------------------------------------
# HEADER FILES

Q: What are forward class declaration?
In windows.h
#ifndef WINDOW_H                    // Include guard
#define WINDOW_H

#include <QWidget>
class QPushButton;                  // QPushButton is a class defined someother place! This is a FORWARD CLASS DECLARATION
class Window : public QWidget
{
    Q_OBJECT
public:
    explicit Window(QWidget *parent = 0);
private:
    QPushButton *a_button;
signals:
    void counterReached();
public slots:

private slots:
    void slotButtonClicked(bool checked);
};
#endif // WINDOW_H

Q: What are include guards?
#ifndef WINDOW_H                    // Include guard
#define WINDOW_H
.... (header file code goes here) ...
#endif // WINDOW_H

Q: What is a proxy class?
A class used as an interface to hide the private data of another class.
That private data would normally appear in the include file (even so it is not in use)
The proxy class header file doesn't need to show the private parameters

#-----------------------------------------------------------------------
# CONST and MUTABLE

Q: What is const-ness?

Q: What method do you know that can change the const-ness?
1/ const_cast, 
2/ mutable 

Q: What does mutable mean?
Mutable is a storage class specifier.
A mutable member is always modifiable even if it's a member of a const object
See command example

Q: what are const member function?
A const member function is defined for example as 
double CommissionEmployee::getCommissionRate() const 
{
    return commissionRate;
}
const member function cannot call non-const function
can be used on 
const object


#-----------------------------------------------------------------------
# CONSTRUCTORS

Q: Are constructors inherited?
No! Each class needs to provide a constructor!

Q: What is a copy constructor?
A friend function? that takes an object as a parameter and returns a reference to a new object
of the same class as its object argument. The private data member of the new object 
have the same value as those of the object passed as arg.
object2 = copy_constructor(object1)

Q: Can a constructor or destructor be a const function? 
No

Q: Can a constructor initialize a const object?
Yes!
The 'constness' of a const object is enforced from the time the contructor COMPLETES
initialization of the object until that object's destructor is called.
const object (or vars) are instantiated with initializers 

Q: Do every class have a copy constructor?
Yes. If none are explicitly declared, the compiler will provide a default one.
Beware of object construction which requires allocation of memory (malloc, calloc type)
Beware of pointers.

Q: What is an implicit conversion?
Here's a simple function that takes a Foo object:
void DoBar (Foo foo)
{
  int i = foo.GetFoo ();
}
and here's where the DoBar function is called.
int main ()
{
  DoBar (42);
}
The parameter is not a Foo object, but an int. However, there exists a constructor for Foo that 
takes an int (Foo::Foo(int foo) ) so this constructor can be used to convert the parameter to the correct type.

Q: what does the explicit keyword mean?
Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. 
Adding it to the above class will create a compiler error at the function call DoBar (42). 
It is now necessary to call for conversion explicitly with DoBar (Foo (42))
i
Q: Why would I want to use the explicit keyword?
The reason you might want to do this is to avoid accidental construction that can hide bugs. 
Contrived example:
You have a MyString(int size) class with a constructor that constructs a string of the given size. 
You have a function print(MyString&), and you call it with print(3). 
You expect it to print "3", but it prints an empty string of length 3 instead.

Q: What are initializers?
Initializers used in constructors (and copy constructors)
MyClass::MyClass(int c, int i)          
    : QWizardPage(parent),              # <-- if a class is part of the initializer, then it is a parent class!
      m_count (c),                      # <-- if not a class (start with lowercase), then it is a const variable
      m_increment (i)                   # <-- another CONST variable !!! 
{
}
Above, the count variable is set = to c, the increment variable is set to i
!!! A const (private) data member is REQUIRED to have an initializer
!!! m_ as in m_count defines a member variable, etc
!!! Non-const variables are not initialized in initializer

Q: When do initializers execute?
Before the body of the constructor execute!

#-----------------------------------------------------------------------
# DESTRUCTORS 

Q: What is a virtual destructor?
A destructor that can be used when polymorphism is used.
!!! Note that the base-class destructor and derived-class destructor do not have the same name !!!
Destruction is done explicitly with the 'delete' command

Q: If destructor can be virtual, can constructor be virtual?
No!

Q: When are destructors of static object run?
When the main exits.
!!! A call to exit runs only the static and global destructor (not the automatic variable)

#-----------------------------------------------------------------------
# FRIEND FUNCTIONS

Q: Is a copy constructor a friend function?

Q: What is a friend function?
A C-style function declared at the same time as the class it 'befriended'
A friend function can have access to private (and protected) data member of that class.
A friend function is NOT a member of that class.
A object is passed as a parameter of that function.

Q: Are friend function inherited?
No, they are not class members!

#-----------------------------------------------------------------------
# THIS

Q: What is 'this'?
Every object has access to its own address through a pointer called this!
'this' is a pointer, but is not part of the object itself!          <-- no need to have &this
'this' is a const pointer on a non-constant object (itself!)        <-- this points to the same memory address, but the content it points to can change!
ex: 
this->privateDataArray[i]
!!! 'this' is not used to access other member functions in a member function, 
!!! WRONG In member function, this->setTime(h,m,s) wiht setTime another member function is WRONG !!!

Q: Who provides the value for 'this'?
The compiler does. The compiles pass the pointer this as a parameter to every member function, except STATIC ones.
!!! this doesn't need to be listed as a parameter (as is the case for self in python!)

Q: In which case is 'this' a 'const Object * const' ?
In a constant member function (where the object cannot be modified)     # <-- the member function cannot change the content of 

#-----------------------------------------------------------------------
# STACK AND HEAP

Q: What is the 'heap'?
Objects that are created using 'new' are them referenced with a pointer into the heap.
The heap (also known as the “free store”) is a large pool of memory used for dynamic allocation.
In C++, when you use the new operator to allocate memory, this memory is assigned from the heap.
ex:
int *pValue = new int;      // pValue is assigned 4 bytes from the heap
int *pArray = new int[10];  // pArray is assigned 40 bytes from the heap
Because the precise location of the memory allocated is not known in advance, 
the memory allocated has to be accessed indirectly — which is why new returns a pointer. 
You do not have to worry about the mechanics behind the process of how free memory is located and allocated to the user. 
However, it is worth knowing that sequential memory requests may not result in sequential memory addresses being allocated!
ex:
int *pValue1 = new int;
int *pValue2 = new int;     // pValue1 and pValue2 may not have sequential addresses
When a dynamically allocated variable is deleted, the memory is “returned” to the heap 
and can then be reassigned as future allocation requests are received.

The heap has advantages and disadvantages:
1) Allocated memory stays allocated until it is specifically deallocated (beware memory leaks).
2) Dynamically allocated memory must be accessed through a pointer.
3) Because the heap is a big pool of memory, large arrays, structures, or classes should be allocated here.

Q: What is the stack?
The call stack (usually referred to as “the stack”) has a much more interesting role to play. 
Before we talk about the call stack, which refers to a particular portion of memory, let’s talk about what a stack is.
Consider a stack of plates in a cafeteria. Because each plate is heavy and they are stacked, you can really only do one of three things:
1) Look at the surface of the top plate
2) Take the top plate off the stack
3) Put a new plate on top of the stack
In computer programming, a stack is a container that holds other variables (much like an array). 
However, whereas an array lets you access and modify elements in any order you wish, a stack is more limited. 
The operations that can be performed on a stack are identical to the ones above:
1) Look at the top item on the stack (usually done via a function called top())
2) Take the top item off of the stack (done via a function called pop())
3) Put a new item on top of the stack (done via a function called push())
A stack is a last-in, first-out (LIFO) structure. The last item pushed onto the stack will be the first item popped off. 
If you put a new plate on top of the stack, anybody who takes a plate from the stack will take the plate you just pushed on first. 
Last on, first off. As items are pushed onto a stack, the stack grows larger — as items are popped off, the stack grows smaller.

The plate analogy is a pretty good analogy as to how the call stack works, but we can actually make an even better analogy. 
Consider a bunch of mailboxes, all stacked on top of each other. 
Each mailbox can only hold one item, and all mailboxes start out empty. 
Furthermore, each mailbox is nailed to the mailbox below it, so the number of mailboxes can not be changed. 
If we can’t change the number of mailboxes, how do we get a stack-like behavior?

First, we use a marker (like a post-it note) to keep track of where the bottom-most empty mailbox is. 
In the beginning, this will be the lowest mailbox. When we push an item onto our mailbox stack, 
we put it in the mailbox that is marked (which is the first empty mailbox), and move the marker up one mailbox. 
When we pop an item off the stack, we move the marker down one mailbox and remove the item from that mailbox. 
Anything below the marker is considered “on the stack”. Anything at the marker or above the marker is not on the stack.

This is almost exactly analogous to how the call stack works. 
The call stack is a fixed-size chunk of sequential memory addresses. 
The mailboxes are memory addresses, and the “items” are pieces of data (typically either variables or addreses). 
The “marker” is a register (a small piece of memory) in the CPU known as the stack pointer. 
The stack pointer keeps track of where the top of the stack currently is.

The only difference between our hypothetical mailbox stack and the call stack is that when we pop an item off the call stack, 
we don’t have to erase the memory (the equivalent of emptying the mailbox). 
We can just leave it to be overwritten by the next item pushed to that piece of memory. 
Because the stack pointer will be below that memory location, we know that memory location is not on the stack.

So what do we push onto our call stack? Parameters, local variables, and... function calls.

