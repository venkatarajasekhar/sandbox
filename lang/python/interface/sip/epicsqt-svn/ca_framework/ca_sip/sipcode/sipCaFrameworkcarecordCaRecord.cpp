/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.10.2 on Fri Apr 22 17:31:55 2011
 */

#include "sipAPICaFramework.h"

#line 4 "CaRecord.sip"
#include <CaRecord.h>
#line 22 "CaRecord.sip"
#include <CaRecord.h>
#line 14 "sipCaFrameworkcarecordCaRecord.cpp"

#line 4 "CaRecord.sip"
#include <CaRecord.h>
#line 22 "CaRecord.sip"
#include <CaRecord.h>
#line 20 "sipCaFrameworkcarecordCaRecord.cpp"
#line 4 "MappedType.sip"
#include <string>
#line 23 "sipCaFrameworkcarecordCaRecord.cpp"
#line 4 "CaRecord.sip"
#include <CaRecord.h>
#line 22 "CaRecord.sip"
#include <CaRecord.h>
#line 28 "sipCaFrameworkcarecordCaRecord.cpp"
#line 4 "Generic.sip"
#include <Generic.h>
#line 12 "Generic.sip"
#include <Generic.h>
#line 33 "sipCaFrameworkcarecordCaRecord.cpp"
#line 4 "Generic.sip"
#include <Generic.h>
#line 12 "Generic.sip"
#include <Generic.h>
#line 38 "sipCaFrameworkcarecordCaRecord.cpp"


class sipcarecord_CaRecord : public carecord::CaRecord
{
public:
    sipcarecord_CaRecord();
    sipcarecord_CaRecord(carecord::CaRecord&);
    ~sipcarecord_CaRecord();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtect_cloneValue(generic::Generic *);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipcarecord_CaRecord(const sipcarecord_CaRecord &);
    sipcarecord_CaRecord &operator = (const sipcarecord_CaRecord &);
};

sipcarecord_CaRecord::sipcarecord_CaRecord(): carecord::CaRecord(), sipPySelf(0)
{
}

sipcarecord_CaRecord::sipcarecord_CaRecord(carecord::CaRecord& a0): carecord::CaRecord(a0), sipPySelf(0)
{
}

sipcarecord_CaRecord::~sipcarecord_CaRecord()
{
    sipCommonDtor(sipPySelf);
}

void sipcarecord_CaRecord::sipProtect_cloneValue(generic::Generic *a0)
{
    generic::Generic::cloneValue(a0);
}


extern "C" {static PyObject *meth_carecord_CaRecord_cloneValue(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_cloneValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        generic::Generic * a0;
        sipcarecord_CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_carecord_CaRecord, &sipCpp, sipType_generic_Generic, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_cloneValue(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_cloneValue, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setName(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::string * a0;
        int a0State = 0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_carecord_CaRecord, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setName(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setName, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setDbrType(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setDbrType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        short a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bh", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setDbrType(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setDbrType, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setDbrTranslation(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setDbrTranslation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::dbr_translation_type a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BE", &sipSelf, sipType_carecord_CaRecord, &sipCpp, sipType_carecord_dbr_translation_type, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setDbrTranslation(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setDbrTranslation, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setValid(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setValid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setValid(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setValid, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_updateProcessState(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_updateProcessState(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->updateProcessState();
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_updateProcessState, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setStatus(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setStatus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        short a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bh", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setStatus(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setStatus, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setAlarmSeverity(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setAlarmSeverity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        short a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bh", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setAlarmSeverity(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setAlarmSeverity, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setPrecision(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setPrecision(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        short a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bh", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setPrecision(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setPrecision, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setUnits(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setUnits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::string * a0;
        int a0State = 0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_carecord_CaRecord, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setUnits(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setUnits, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setTimeStamp(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setTimeStamp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        unsigned long a0;
        unsigned long a1;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bmm", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setTimeStamp(a0,a1);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setTimeStamp, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setRiscAlignment(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setRiscAlignment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setRiscAlignment(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setRiscAlignment, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_addEnumState(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_addEnumState(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::string * a0;
        int a0State = 0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_carecord_CaRecord, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->addEnumState(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_addEnumState, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setDisplayLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setDisplayLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bdd", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setDisplayLimit(a0,a1);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setDisplayLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setAlarmLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setAlarmLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bdd", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setAlarmLimit(a0,a1);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setAlarmLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setWarningLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setWarningLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bdd", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setWarningLimit(a0,a1);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setWarningLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_setControlLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_setControlLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bdd", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setControlLimit(a0,a1);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_setControlLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getName(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            std::string *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new std::string(sipCpp->getName());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getName, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getDbrType(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getDbrType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            short sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getDbrType();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getDbrType, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_isValid(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_isValid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->isValid();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_isValid, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getProcessState(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getProcessState(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            carecord::process_state sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getProcessState();
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(sipRes,sipType_carecord_process_state);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getProcessState, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_isFirstUpdate(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_isFirstUpdate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->isFirstUpdate();
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_isFirstUpdate, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getStatus(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getStatus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            short sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getStatus();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getStatus, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getAlarmSeverity(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getAlarmSeverity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            short sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getAlarmSeverity();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getAlarmSeverity, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getPrecision(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getPrecision(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            short sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getPrecision();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getPrecision, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getUnits(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getUnits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            std::string *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new std::string(sipCpp->getUnits());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getUnits, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getTimeStampSeconds(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getTimeStampSeconds(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            unsigned long sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getTimeStampSeconds();
            Py_END_ALLOW_THREADS

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getTimeStampSeconds, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getTimeStampNanoseconds(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getTimeStampNanoseconds(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            unsigned long sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getTimeStampNanoseconds();
            Py_END_ALLOW_THREADS

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getTimeStampNanoseconds, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getRiscAlignment(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getRiscAlignment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getRiscAlignment();
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getRiscAlignment, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getEnumState(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getEnumState(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_carecord_CaRecord, &sipCpp, &a0))
        {
            std::string *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new std::string(sipCpp->getEnumState(a0));
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getEnumState, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getEnumStateCount(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getEnumStateCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->getEnumStateCount();
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getEnumStateCount, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getDisplayLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getDisplayLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            carecord::ca_limit *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new carecord::ca_limit(sipCpp->getDisplayLimit());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_carecord_ca_limit,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getDisplayLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getAlarmLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getAlarmLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            carecord::ca_limit *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new carecord::ca_limit(sipCpp->getAlarmLimit());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_carecord_ca_limit,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getAlarmLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getWarningLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getWarningLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            carecord::ca_limit *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new carecord::ca_limit(sipCpp->getWarningLimit());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_carecord_ca_limit,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getWarningLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_getControlLimit(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_getControlLimit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        carecord::CaRecord *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_carecord_CaRecord, &sipCpp))
        {
            carecord::ca_limit *sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new carecord::ca_limit(sipCpp->getControlLimit());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_carecord_ca_limit,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_CaRecord, sipName_getControlLimit, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_carecord_CaRecord_reset(PyObject *, PyObject *);}
static PyObject *meth_carecord_CaRecord_reset(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_CaRecord, sipName_reset, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_carecord_CaRecord(void *, const sipTypeDef *);}
static void *cast_carecord_CaRecord(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_carecord_CaRecord)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_generic_Generic)->ctd_cast((generic::Generic *)(carecord::CaRecord *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_carecord_CaRecord(void *, int);}
static void release_carecord_CaRecord(void *sipCppV,int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipcarecord_CaRecord *>(sipCppV);
    else
        delete reinterpret_cast<carecord::CaRecord *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_carecord_CaRecord(sipSimpleWrapper *);}
static void dealloc_carecord_CaRecord(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipcarecord_CaRecord *>(sipSelf->u.cppPtr)->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_carecord_CaRecord(sipSelf->u.cppPtr,sipSelf->flags);
    }
}


extern "C" {static void *init_carecord_CaRecord(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_carecord_CaRecord(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipcarecord_CaRecord *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipcarecord_CaRecord();
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        carecord::CaRecord * a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_carecord_CaRecord, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipcarecord_CaRecord(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_carecord_CaRecord[] = {{31, 255, 1}};


static PyMethodDef methods_carecord_CaRecord[] = {
    {SIP_MLNAME_CAST(sipName_addEnumState), meth_carecord_CaRecord_addEnumState, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_cloneValue), meth_carecord_CaRecord_cloneValue, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getAlarmLimit), meth_carecord_CaRecord_getAlarmLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getAlarmSeverity), meth_carecord_CaRecord_getAlarmSeverity, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getControlLimit), meth_carecord_CaRecord_getControlLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getDbrType), meth_carecord_CaRecord_getDbrType, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getDisplayLimit), meth_carecord_CaRecord_getDisplayLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getEnumState), meth_carecord_CaRecord_getEnumState, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getEnumStateCount), meth_carecord_CaRecord_getEnumStateCount, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getName), meth_carecord_CaRecord_getName, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getPrecision), meth_carecord_CaRecord_getPrecision, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getProcessState), meth_carecord_CaRecord_getProcessState, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getRiscAlignment), meth_carecord_CaRecord_getRiscAlignment, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getStatus), meth_carecord_CaRecord_getStatus, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getTimeStampNanoseconds), meth_carecord_CaRecord_getTimeStampNanoseconds, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getTimeStampSeconds), meth_carecord_CaRecord_getTimeStampSeconds, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getUnits), meth_carecord_CaRecord_getUnits, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_getWarningLimit), meth_carecord_CaRecord_getWarningLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_isFirstUpdate), meth_carecord_CaRecord_isFirstUpdate, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_isValid), meth_carecord_CaRecord_isValid, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_reset), meth_carecord_CaRecord_reset, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setAlarmLimit), meth_carecord_CaRecord_setAlarmLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setAlarmSeverity), meth_carecord_CaRecord_setAlarmSeverity, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setControlLimit), meth_carecord_CaRecord_setControlLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setDbrTranslation), meth_carecord_CaRecord_setDbrTranslation, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setDbrType), meth_carecord_CaRecord_setDbrType, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setDisplayLimit), meth_carecord_CaRecord_setDisplayLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setName), meth_carecord_CaRecord_setName, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setPrecision), meth_carecord_CaRecord_setPrecision, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setRiscAlignment), meth_carecord_CaRecord_setRiscAlignment, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setStatus), meth_carecord_CaRecord_setStatus, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setTimeStamp), meth_carecord_CaRecord_setTimeStamp, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setUnits), meth_carecord_CaRecord_setUnits, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setValid), meth_carecord_CaRecord_setValid, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_setWarningLimit), meth_carecord_CaRecord_setWarningLimit, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_updateProcessState), meth_carecord_CaRecord_updateProcessState, METH_VARARGS, NULL}
};


pyqt4ClassTypeDef sipTypeDef_CaFramework_carecord_CaRecord = {
{
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_carecord__CaRecord,
        {0}
    },
    {
        sipNameNr_CaRecord,
        {25, 255, 0},
        36, methods_carecord_CaRecord,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    supers_carecord_CaRecord,
    0,
    init_carecord_CaRecord,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_carecord_CaRecord,
    0,
    0,
    0,
    release_carecord_CaRecord,
    cast_carecord_CaRecord,
    0,
    0,
    0
},
    0,
    0,
    0
};
